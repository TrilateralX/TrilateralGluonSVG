// Generated by Haxe 4.2.0-rc.1+354c24d30
#include <hxcpp.h>

#ifndef INCLUDED_c8a65390b4b62196
#define INCLUDED_c8a65390b4b62196
#include "/usr/local/lib/haxeLibrary/gluon/git/src/gluon/webgl/native/ES2Context.h"
#endif
#ifndef INCLUDED_2710e462964f946c
#define INCLUDED_2710e462964f946c
#include "stdlib.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_dsHelper_flatInterleave_core__Flat32_Flat32_Impl_
#include <dsHelper/flatInterleave/core/_Flat32/Flat32_Impl_.h>
#endif
#ifndef INCLUDED_gluon_webgl__GLContext_GLContext_Impl_
#include <gluon/webgl/_GLContext/GLContext_Impl_.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLBuffer
#include <gluon/webgl/native/GLBuffer.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLContext
#include <gluon/webgl/native/GLContext.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLObject
#include <gluon/webgl/native/GLObject.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLProgram
#include <gluon/webgl/native/GLProgram.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLShader
#include <gluon/webgl/native/GLShader.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io__Float32Array_Float32Array_Impl_
#include <haxe/io/_Float32Array/Float32Array_Impl_.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_nodule_PenNodule
#include <trilateral3/nodule/PenNodule.h>
#endif
#ifndef INCLUDED_trilateralGluonChange_AppGL
#include <trilateralGluonChange/AppGL.h>
#endif
#ifndef INCLUDED_typedarray_ArrayBufferView
#include <typedarray/ArrayBufferView.h>
#endif
#ifndef INCLUDED_typedarray_ArrayBufferViewBase
#include <typedarray/ArrayBufferViewBase.h>
#endif
#ifndef INCLUDED_typedarray_Float32ArrayImpl
#include <typedarray/Float32ArrayImpl.h>
#endif

namespace trilateralGluonChange{

void AppGL_obj::__construct(int width_,int height_){
            	HX_JUST_GC_STACKFRAME
	this->penNodule =  ::trilateral3::nodule::PenNodule_obj::__alloc( HX_CTX );
	this->gl = ::trilateralGluonChange::AppGL_obj::gl_;
	this->width = width_;
	this->height = height_;
	::trilateralGluonChange::AppGL_obj::appGL = ::hx::ObjectPtr<OBJ_>(this);
	{
		 ::gluon::webgl::native::GLContext gl = this->gl;
		 ::gluon::webgl::native::GLContext this1 = gl;
		unsigned int ref = glCreateProgram();
		 ::gluon::webgl::native::GLProgram v;
		if ((ref != 0)) {
			v =  ::gluon::webgl::native::GLProgram_obj::__alloc( HX_CTX ,this1,ref);
		}
		else {
			v = null();
		}
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("createProgram",e8,22,3c,dc));
		 ::gluon::webgl::native::GLProgram program = v;
		{
			 ::gluon::webgl::native::GLContext this2 = gl;
			unsigned int ref1 = glCreateShader(( (unsigned int)(35633) ));
			 ::gluon::webgl::native::GLShader v1;
			if ((ref1 != 0)) {
				v1 =  ::gluon::webgl::native::GLShader_obj::__alloc( HX_CTX ,this2,ref1);
			}
			else {
				v1 = null();
			}
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this2,HX_("createShader",41,ff,75,3f));
			 ::gluon::webgl::native::GLShader shader = v1;
			{
				gl->shaderSource(shader,((((((HX_("attribute vec3 vertexPosition;",31,27,01,79) + HX_("attribute vec4 vertexColor;",b8,a7,4a,43)) + HX_("varying vec4 vcol;",61,c8,5b,03)) + HX_("void main(void) {",4d,18,fb,21)) + HX_(" gl_Position = vec4(vertexPosition, 1.0);",1c,0c,87,98)) + HX_(" vcol = vertexColor;",75,ef,b6,2e)) + HX_("}",7d,00,00,00)));
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("shaderSource",e0,4d,1a,a2));
			}
			{
				glCompileShader(shader->handle);
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("compileShader",f8,70,b2,da));
			}
			 ::gluon::webgl::native::GLShader shader1;
			 ::gluon::webgl::native::GLContext this3 = gl;
			bool v2 = ( (bool)(this3->getShaderParameter(shader,( (unsigned int)(35713) ))) );
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this3,HX_("getShaderParameter",ce,69,5b,36));
			if (!(v2)) {
				 ::gluon::webgl::native::GLContext this1 = gl;
				::String v = this1->getShaderInfoLog(shader);
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("getShaderInfoLog",9b,bd,c8,f3));
				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error compiling shader. ",bf,50,4d,23) + v)));
			}
			else {
				shader1 = shader;
			}
			glAttachShader(program->handle,shader1->handle);
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("attachShader",ca,d0,77,b2));
		}
		{
			 ::gluon::webgl::native::GLContext this4 = gl;
			unsigned int ref2 = glCreateShader(( (unsigned int)(35632) ));
			 ::gluon::webgl::native::GLShader v3;
			if ((ref2 != 0)) {
				v3 =  ::gluon::webgl::native::GLShader_obj::__alloc( HX_CTX ,this4,ref2);
			}
			else {
				v3 = null();
			}
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this4,HX_("createShader",41,ff,75,3f));
			 ::gluon::webgl::native::GLShader shader2 = v3;
			{
				gl->shaderSource(shader2,((((HX_("precision mediump float;",e6,f2,15,86) + HX_("varying vec4 vcol;",61,c8,5b,03)) + HX_("void main(void) {",4d,18,fb,21)) + HX_(" gl_FragColor = vcol;",25,af,1c,24)) + HX_("}",7d,00,00,00)));
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("shaderSource",e0,4d,1a,a2));
			}
			{
				glCompileShader(shader2->handle);
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("compileShader",f8,70,b2,da));
			}
			 ::gluon::webgl::native::GLShader shader3;
			 ::gluon::webgl::native::GLContext this5 = gl;
			bool v4 = ( (bool)(this5->getShaderParameter(shader2,( (unsigned int)(35713) ))) );
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this5,HX_("getShaderParameter",ce,69,5b,36));
			if (!(v4)) {
				 ::gluon::webgl::native::GLContext this1 = gl;
				::String v = this1->getShaderInfoLog(shader2);
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("getShaderInfoLog",9b,bd,c8,f3));
				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error compiling shader. ",bf,50,4d,23) + v)));
			}
			else {
				shader3 = shader2;
			}
			glAttachShader(program->handle,shader3->handle);
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("attachShader",ca,d0,77,b2));
		}
		{
			glLinkProgram(program->handle);
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("linkProgram",aa,ad,7b,89));
		}
		 ::gluon::webgl::native::GLProgram _hx_tmp;
		int ref3 = 0;
		unsigned int program1 = program->handle;
		glGetProgramiv(program1,( (unsigned int)(35714) ),hx::StarOf(ref3));
		bool v5 = ( (bool)(ref3) );
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("getProgramParameter",3b,c3,9c,96));
		if (!(v5)) {
			 ::gluon::webgl::native::GLContext this1 = gl;
			::String v = this1->getProgramInfoLog(program);
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("getProgramInfoLog",c8,f1,f2,cd));
			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error linking program. ",46,e8,c7,f8) + v)));
		}
		else {
			{
				glValidateProgram(program->handle);
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("validateProgram",8e,80,0f,ef));
			}
			int ref = 0;
			unsigned int program1 = program->handle;
			glGetProgramiv(program1,( (unsigned int)(35715) ),hx::StarOf(ref));
			bool v = ( (bool)(ref) );
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("getProgramParameter",3b,c3,9c,96));
			if (!(v)) {
				 ::gluon::webgl::native::GLContext this1 = gl;
				::String v = this1->getProgramInfoLog(program);
				::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("getProgramInfoLog",c8,f1,f2,cd));
				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error validating program. ",21,2c,33,3d) + v)));
			}
			else {
				{
					{
						unsigned int ref;
						if (::hx::IsNotNull( program )) {
							ref = program->handle;
						}
						else {
							ref = ( (unsigned int)(0) );
						}
						glUseProgram(ref);
					}
					::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("useProgram",fd,6c,ac,f6));
				}
				_hx_tmp = program;
			}
		}
		this->program = _hx_tmp;
		this->draw(this->penNodule->pen);
		 ::gluon::webgl::native::GLContext gl1 = this->gl;
		 ::gluon::webgl::native::GLProgram program2 = this->program;
		 ::haxe::io::ArrayBufferViewImpl this6 = this->penNodule->colorTriangles;
		 ::Dynamic end = ((this6->byteLength >> 2) - 2);
		 ::Dynamic data;
		if (::hx::IsNull( end )) {
			data = null();
		}
		else {
			data = (( (int)(end) ) << 2);
		}
		 ::typedarray::Float32ArrayImpl data1 = ( ( ::typedarray::Float32ArrayImpl)(::haxe::io::_Float32Array::Float32Array_Impl__obj::fromData(this6->subarray(8,data))) );
		 ::Dynamic isDynamic = true;
		if (::hx::IsNull( isDynamic )) {
			isDynamic = false;
		}
		 ::Dynamic isDynamic1 = isDynamic;
		if (::hx::IsNull( isDynamic1 )) {
			isDynamic1 = false;
		}
		 ::gluon::webgl::native::GLContext this7 = gl1;
		unsigned int ref4 = ( (unsigned int)(0) );
		glGenBuffers(1,hx::StarOf(ref4));
		 ::gluon::webgl::native::GLBuffer v6;
		if ((ref4 != 0)) {
			v6 =  ::gluon::webgl::native::GLBuffer_obj::__alloc( HX_CTX ,this7,ref4);
		}
		else {
			v6 = null();
		}
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this7,HX_("createBuffer",1c,fd,e9,f2));
		 ::gluon::webgl::native::GLBuffer buf = v6;
		{
			{
				unsigned int ref5;
				if (::hx::IsNotNull( buf )) {
					ref5 = buf->handle;
				}
				else {
					ref5 = ( (unsigned int)(0) );
				}
				glBindBuffer(( (unsigned int)(34962) ),ref5);
			}
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("bindBuffer",9d,92,be,f8));
		}
		if (( (bool)(isDynamic1) )) {
			int data = ( ( ::haxe::io::Bytes)(data1) )->length;
			::cpp::Pointer< unsigned char > _hx_tmp = ( (::cpp::Pointer< unsigned char >)(::cpp::Pointer_obj::arrayElem(( ( ::haxe::io::Bytes)(data1) )->b,0)) );
			glBufferData(( (unsigned int)(34962) ),( (::cpp::Int64)(data) ),( (const void *)(( (unsigned char *)(_hx_tmp->get_raw()) )) ),( (unsigned int)(35048) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("bufferData",4a,bf,73,93));
		}
		else {
			int data = ( ( ::haxe::io::Bytes)(data1) )->length;
			::cpp::Pointer< unsigned char > _hx_tmp = ( (::cpp::Pointer< unsigned char >)(::cpp::Pointer_obj::arrayElem(( ( ::haxe::io::Bytes)(data1) )->b,0)) );
			glBufferData(( (unsigned int)(34962) ),( (::cpp::Int64)(data) ),( (const void *)(( (unsigned char *)(_hx_tmp->get_raw()) )) ),( (unsigned int)(35044) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("bufferData",4a,bf,73,93));
		}
		 ::gluon::webgl::native::GLBuffer vbo = buf;
		const char* this8 = HX_("vertexPosition",2d,3c,14,50).utf8_str();
		const char* nameCharStar = this8;
		int v7 = glGetAttribLocation(program2->handle,nameCharStar);
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("getAttribLocation",d5,1a,10,5d));
		int posLoc = v7;
		const char* this9 = HX_("vertexColor",5f,3b,98,5e).utf8_str();
		const char* nameCharStar1 = this9;
		int v8 = glGetAttribLocation(program2->handle,nameCharStar1);
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("getAttribLocation",d5,1a,10,5d));
		int colorLoc = v8;
		{
			{
				const void * offsetAsPointer = reinterpret_cast<void*>(0);
				glVertexAttribPointer(( (unsigned int)(posLoc) ),3,( (unsigned int)(5126) ),false,28,offsetAsPointer);
			}
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("vertexAttribPointer",8f,04,b6,3f));
		}
		{
			{
				const void * offsetAsPointer1 = reinterpret_cast<void*>(12);
				glVertexAttribPointer(( (unsigned int)(colorLoc) ),4,( (unsigned int)(5126) ),false,28,offsetAsPointer1);
			}
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("vertexAttribPointer",8f,04,b6,3f));
		}
		{
			glEnableVertexAttribArray(( (unsigned int)(posLoc) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("enableVertexAttribArray",e8,46,5a,ac));
		}
		{
			glEnableVertexAttribArray(( (unsigned int)(colorLoc) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl1,HX_("enableVertexAttribArray",e8,46,5a,ac));
		}
		this->buf = vbo;
	}
}

Dynamic AppGL_obj::__CreateEmpty() { return new AppGL_obj; }

void *AppGL_obj::_hx_vtable = 0;

Dynamic AppGL_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AppGL_obj > _hx_result = new AppGL_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool AppGL_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x49de47f3;
}

void AppGL_obj::draw( ::trilateral3::drawing::Pen pen){
}


HX_DEFINE_DYNAMIC_FUNC1(AppGL_obj,draw,(void))

void AppGL_obj::render(){
	{
		 ::gluon::webgl::native::GLContext gl = ::trilateralGluonChange::AppGL_obj::gl_;
		{
			glViewport(0,0,this->width,this->height);
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("viewport",66,4c,a5,9c));
		}
		{
			glClearColor(( (float)(((Float)0.0)) ),( (float)(((Float)0.0)) ),( (float)(((Float)0.0)) ),( (float)(((Float)1.0)) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("clearColor",96,b0,66,1f));
		}
		{
			glClear(( (unsigned int)(16384) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("clear",8d,71,5b,48));
		}
	}
	this->renderDraw(this->penNodule->pen);
	{
		 ::gluon::webgl::native::GLContext this1 = this->gl;
		 ::gluon::webgl::native::GLBuffer buffer = this->buf;
		{
			unsigned int ref;
			if (::hx::IsNotNull( buffer )) {
				ref = buffer->handle;
			}
			else {
				ref = ( (unsigned int)(0) );
			}
			glBindBuffer(( (unsigned int)(34962) ),ref);
		}
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("bindBuffer",9d,92,be,f8));
	}
	{
		 ::gluon::webgl::native::GLContext this2 = this->gl;
		 ::haxe::io::ArrayBufferViewImpl this3 = this->penNodule->colorTriangles;
		 ::Dynamic end = ((this3->byteLength >> 2) - 2);
		 ::Dynamic data;
		if (::hx::IsNull( end )) {
			data = null();
		}
		else {
			data = (( (int)(end) ) << 2);
		}
		 ::haxe::io::Bytes data1 = ( ( ::haxe::io::Bytes)(::haxe::io::_Float32Array::Float32Array_Impl__obj::fromData(this3->subarray(8,data))) );
		int data2 = data1->length;
		::cpp::Pointer< unsigned char > _hx_tmp = ( (::cpp::Pointer< unsigned char >)(::cpp::Pointer_obj::arrayElem(data1->b,0)) );
		glBufferSubData(( (unsigned int)(34962) ),( (::cpp::Int64)(0) ),( (::cpp::Int64)(data2) ),( (const void *)(( (unsigned char *)(_hx_tmp->get_raw()) )) ));
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this2,HX_("bufferSubData",aa,f6,e4,45));
	}
	{
		 ::gluon::webgl::native::GLContext this4 = this->gl;
		 ::gluon::webgl::native::GLProgram program = this->program;
		{
			unsigned int ref1;
			if (::hx::IsNotNull( program )) {
				ref1 = program->handle;
			}
			else {
				ref1 = ( (unsigned int)(0) );
			}
			glUseProgram(ref1);
		}
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this4,HX_("useProgram",fd,6c,ac,f6));
	}
	{
		 ::gluon::webgl::native::GLContext this5 = this->gl;
		glDrawArrays(( (unsigned int)(4) ),0,::Std_obj::_hx_int(( (Float)((::dsHelper::flatInterleave::core::_Flat32::Flat32_Impl__obj::get_size(this->penNodule->colorTriangles) * 3)) )));
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this5,HX_("drawArrays",de,f3,b3,f9));
	}
}


HX_DEFINE_DYNAMIC_FUNC0(AppGL_obj,render,(void))

void AppGL_obj::renderDraw( ::trilateral3::drawing::Pen pen){
}


HX_DEFINE_DYNAMIC_FUNC1(AppGL_obj,renderDraw,(void))

 ::gluon::webgl::native::GLContext AppGL_obj::gl_;

 ::trilateralGluonChange::AppGL AppGL_obj::appGL;

void AppGL_obj::init(){
            	HX_JUST_GC_STACKFRAME
	::trilateralGluonChange::AppGL_obj::gl_ =  ::gluon::webgl::native::GLContext_obj::__alloc( HX_CTX );
}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(AppGL_obj,init,(void))

void AppGL_obj::onFrame(){
	__hxcpp_collect(true);
	Float t_s =  ::__time_stamp();
	::trilateralGluonChange::AppGL_obj::appGL->render();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(AppGL_obj,onFrame,(void))


::hx::ObjectPtr< AppGL_obj > AppGL_obj::__new(int width_,int height_) {
	::hx::ObjectPtr< AppGL_obj > __this = new AppGL_obj();
	__this->__construct(width_,height_);
	return __this;
}

::hx::ObjectPtr< AppGL_obj > AppGL_obj::__alloc(::hx::Ctx *_hx_ctx,int width_,int height_) {
	AppGL_obj *__this = (AppGL_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(AppGL_obj), true, "trilateralGluonChange.AppGL"));
	*(void **)__this = AppGL_obj::_hx_vtable;
	__this->__construct(width_,height_);
	return __this;
}

AppGL_obj::AppGL_obj()
{
}

void AppGL_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(AppGL);
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(program,"program");
	HX_MARK_MEMBER_NAME(penNodule,"penNodule");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(buf,"buf");
	HX_MARK_END_CLASS();
}

void AppGL_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(program,"program");
	HX_VISIT_MEMBER_NAME(penNodule,"penNodule");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(buf,"buf");
}

::hx::Val AppGL_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return ::hx::Val( gl ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"buf") ) { return ::hx::Val( buf ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"program") ) { return ::hx::Val( program ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"penNodule") ) { return ::hx::Val( penNodule ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"renderDraw") ) { return ::hx::Val( renderDraw_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool AppGL_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"gl_") ) { outValue = ( gl_ ); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"appGL") ) { outValue = ( appGL ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onFrame") ) { outValue = onFrame_dyn(); return true; }
	}
	return false;
}

::hx::Val AppGL_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::gluon::webgl::native::GLContext >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"buf") ) { buf=inValue.Cast<  ::gluon::webgl::native::GLBuffer >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"program") ) { program=inValue.Cast<  ::gluon::webgl::native::GLProgram >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"penNodule") ) { penNodule=inValue.Cast<  ::trilateral3::nodule::PenNodule >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool AppGL_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"gl_") ) { gl_=ioValue.Cast<  ::gluon::webgl::native::GLContext >(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"appGL") ) { appGL=ioValue.Cast<  ::trilateralGluonChange::AppGL >(); return true; }
	}
	return false;
}

void AppGL_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("gl",25,5a,00,00));
	outFields->push(HX_("program",84,4a,f9,f3));
	outFields->push(HX_("penNodule",c4,02,81,14));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("buf",33,c3,4a,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo AppGL_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::gluon::webgl::native::GLContext */ ,(int)offsetof(AppGL_obj,gl),HX_("gl",25,5a,00,00)},
	{::hx::fsObject /*  ::gluon::webgl::native::GLProgram */ ,(int)offsetof(AppGL_obj,program),HX_("program",84,4a,f9,f3)},
	{::hx::fsObject /*  ::trilateral3::nodule::PenNodule */ ,(int)offsetof(AppGL_obj,penNodule),HX_("penNodule",c4,02,81,14)},
	{::hx::fsInt,(int)offsetof(AppGL_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsInt,(int)offsetof(AppGL_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsObject /*  ::gluon::webgl::native::GLBuffer */ ,(int)offsetof(AppGL_obj,buf),HX_("buf",33,c3,4a,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo AppGL_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::gluon::webgl::native::GLContext */ ,(void *) &AppGL_obj::gl_,HX_("gl_",9a,86,4e,00)},
	{::hx::fsObject /*  ::trilateralGluonChange::AppGL */ ,(void *) &AppGL_obj::appGL,HX_("appGL",06,65,3b,24)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String AppGL_obj_sMemberFields[] = {
	HX_("gl",25,5a,00,00),
	HX_("program",84,4a,f9,f3),
	HX_("penNodule",c4,02,81,14),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("buf",33,c3,4a,00),
	HX_("draw",04,2c,70,42),
	HX_("render",56,6b,29,05),
	HX_("renderDraw",7a,26,7a,df),
	::String(null()) };

static void AppGL_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(AppGL_obj::gl_,"gl_");
	HX_MARK_MEMBER_NAME(AppGL_obj::appGL,"appGL");
};

#ifdef HXCPP_VISIT_ALLOCS
static void AppGL_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(AppGL_obj::gl_,"gl_");
	HX_VISIT_MEMBER_NAME(AppGL_obj::appGL,"appGL");
};

#endif

::hx::Class AppGL_obj::__mClass;

static ::String AppGL_obj_sStaticFields[] = {
	HX_("gl_",9a,86,4e,00),
	HX_("appGL",06,65,3b,24),
	HX_("init",10,3b,bb,45),
	HX_("onFrame",8e,16,c1,9c),
	::String(null())
};

void AppGL_obj::__register()
{
	AppGL_obj _hx_dummy;
	AppGL_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateralGluonChange.AppGL",8b,83,03,3b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &AppGL_obj::__GetStatic;
	__mClass->mSetStaticField = &AppGL_obj::__SetStatic;
	__mClass->mMarkFunc = AppGL_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(AppGL_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AppGL_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AppGL_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = AppGL_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AppGL_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AppGL_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateralGluonChange
